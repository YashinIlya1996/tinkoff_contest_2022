from math import sqrt, ceil
""" Примечание: Из условия не совсем понято, x0 должен не расстроить Петю при любой последовательности
    выбора элементов из A, или хотя бы для одной. Судя по выходным данным примера №3 - хотя бы для одной,
    иначе - должно быть 11. Чтобы привести решение к гарантированному ответу для любой выборки, нужно в сортировке
    поставить reverse=False.  """


def main():
    """ x[i] = (x[i - 1] ** 2 - a), тогда для того чтобы x[i] был неотрицательным:
        x[i - 1] = ceil(sqrt(x[i] + a)). Несложно показать, что x0, удовлетворяющее условию, будет минималным,
        если элементы из мультимножества доставать в порядке возрастания. Таким образом А представим в виде
        отсортированного по убыванию списка и пройдемся от наибольшего элемента, вычисляя минимальное x[i - 1].
        Сложность в основном определяется сложностью сортировки, O(nlog(n)) + O(n) """
    input()
    a = sorted([el for el in map(int, input().split())], reverse=True)
    x_prev = ceil(sqrt(a.pop(0)))
    for el in a:
        x_curr = ceil(sqrt(x_prev + el))
        x_prev = x_curr
    print(x_prev)


if __name__ == '__main__':
    main()
